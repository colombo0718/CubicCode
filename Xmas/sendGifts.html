<div id="canvas" style="width: 1600px;height: 800px;"></div>
<button id="startButton">開始</button>
<input type="file" id="fileInput" accept=".vox" />
<h3>A:向左 / D:向右 / Space:發射</h3>
<script src="https://unpkg.com/blockly/blockly.min.js"></script>
<script type="importmap">
    {
        "imports": {
            "three": "https://threejs.org/build/three.module.js",
            "three/addons/": "https://threejs.org/examples/jsm/"
        }
    }
</script>
<script type="module">
    import * as THREE from 'three';
    import { VOXLoader, VOXMesh } from 'three/addons/loaders/VOXLoader.js';

    var fileInput = document.getElementById('fileInput');
    var canvas = document.getElementById('canvas');
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
    var renderer = new THREE.WebGLRenderer({ antialias: true });

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

    renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    canvas.appendChild(renderer.domElement);

    // 設置相機
    camera.position.y = 15/Math.sqrt(2);
    camera.position.z = 45/Math.sqrt(2);
    camera.rotation.x=-Math.PI/16

    // 添加燈光
    var ambientLight = new THREE.AmbientLight(0xffffff, 1); // 產生柔和的光
    scene.add(ambientLight);

    var directionalLight = new THREE.DirectionalLight(0xffffcc, 1); // 產生方向光
    directionalLight.position.set(1, 30, -6);
    directionalLight.castShadow = true; // 讓此光能產生陰影
    scene.add(directionalLight);
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;

    directionalLight.shadow.camera.left = -50;
    directionalLight.shadow.camera.right = 50;
    directionalLight.shadow.camera.top = 50;
    directionalLight.shadow.camera.bottom = -50;
    directionalLight.shadow.camera.near = 1;
    directionalLight.shadow.camera.far = 200;
    console.log(directionalLight)

    // 添加網格
    // var grids=[]   
    // var gridSize = 100; // 網格大小
    // var gridDivisions = 10; // 網格分段數
    // var gridColor1 = 0x00ff00;
    // var gridColor2 = 0x009900;
    // for (var i = -200; i <= 100; i += 100) {
    //     var grid = new THREE.GridHelper(gridSize, gridDivisions, gridColor1, gridColor2);
    //     grid.position.set(0, 0, i);
    //     scene.add(grid);
    //     grids.push(grid);
    // }

    const voxelSettings = [
        { name: "runDeer", opacity: 1,  amount: 1   ,radius:10},
        { name: "gift1",  opacity: 1,  amount: 1 ,radius:2 },
        { name: "house",  opacity: 1, amount: 1   ,radius:5 },
        { name: "snowGnd",   opacity: 1,  amount: 5   ,radius:5 },
        { name: "building",   opacity: 1,  amount:1   ,radius:5 },
        { name: "helicopter",   opacity: 1,  amount:1   ,radius:5 }
        // 可以添加更多的voxel模型设置
    ];
    const voxelAnimas = {}; // 存储每个voxel模型的数组

    // 加载voxel模型
        function createModelArray(chunks,opacity,amount,raduis){
            const models = [];
            for (let i = 0; i < amount; i++) {
                const voxelObject = new THREE.Object3D();
                for (let j = 0; j < chunks.length; j++) {
                    const chunk = chunks[j];
                    const mesh = new VOXMesh(chunk);
                    mesh.scale.setScalar(0.1);
                    // mesh.material.transparent = true;
                    // mesh.material.emissive.set(0x008888);
                    // mesh.material.opacity = opacity;
                    mesh.receiveShadow = true
                    mesh.castShadow = true;
                    // mesh.clipShadows = true;
                    voxelObject.add(mesh);
                }
                voxelObject.radius=raduis/10
                scene.add(voxelObject);
                models.push(voxelObject);
            }
            return models
        }

        const loader = new VOXLoader();
        for (const voxelSet of voxelSettings) {
            loader.load('https://cubiccode.vercel.app/Xmas/'+voxelSet.name+'.vox',
            function (chunks){
                const models=createModelArray(chunks,voxelSet.opacity,voxelSet.amount,voxelSet.radius)
                voxelAnimas[voxelSet.name] = models;
            })
        }

    // 上傳選定戰機
    fileInput.addEventListener('change', function (event) {
        if (!event.target.files.length) {
            console.log('No files were selected!');
            return; // 直接返回，不執行後面的代碼
        }
        scene.remove(voxelAnimas['fighter'][0])
        var file = event.target.files[0];
        var reader = new FileReader();
        console.log(voxelAnimas )
        reader.onload = function (event) {
            var contents = event.target.result;
            const loader = new VOXLoader();
            var chunks= loader.parse(contents)
            const models=createModelArray(chunks,1,1,10)
            voxelAnimas['fighter'] = models;
        };
        reader.readAsArrayBuffer(file);
        clearInterval(intervalID);
        gameProcess()
    });

    // 繪製voxel動畫
    var slowIndex=0
    setInterval(function () {
        slowIndex+=1
        for (const voxelName in voxelAnimas) {
            const voxelObjectsArray = voxelAnimas[voxelName];
            for (let i = 0; i < voxelObjectsArray.length; i++) {
                const voxelObject = voxelObjectsArray[i];
                const currentIndex = slowIndex % voxelObject.children.length;
                for (let j = 0; j < voxelObject.children.length; j++) {
                    var voxelMesh=voxelObject.children[j]
                    voxelMesh.visible = j === currentIndex;
                }
            }
        }
    }, 100);

    // 渲染畫面
    var fastIndex=0
    setInterval(function() {
        fastIndex+=1
        renderer.render(scene, camera);
    },30)

    let keys = {};
    document.addEventListener('keydown', function(event) {
        // 將 event.key 轉換成小寫，並儲存到 keys 物件中
        const key = event.key.toLowerCase();
        keys[key] = true; // 設置按鍵為 true 表示按下該按鍵
    });

    document.addEventListener('keyup', function(event) {
        // 將 event.key 轉換成小寫，並儲存到 keys 物件中
        const key = event.key.toLowerCase();
        keys[key] = false; // 設置按鍵為 false 表示釋放該按鍵
    });

    // 遊戲主流程
    var intervalID
    var startLoop=function(){}
    function gameProcess(){
        let score=0
        let runDeer=voxelAnimas["runDeer"][0]
        let ground=voxelAnimas["snowGnd"]
        let house=voxelAnimas["house"][0]
        let gift1=voxelAnimas["gift1"][0]
        let building=voxelAnimas["building"][0]
        let helicopter=voxelAnimas["helicopter"][0]
        let Ay=-.01
        gift1.Vy=.1
        // let bullets=voxelAnimas["bullet"]
        // let energy =voxelAnimas["energy"]
        // let rock1  =voxelAnimas["rock1"]
        // let bulletIndex = 0
        var Santa=new THREE.Object3D();
        Santa.add(runDeer)
        Santa.add(gift1)
        Santa.position.set(-20,10,0)
        building.position.set(10,0,0)
        scene.add(Santa)
        // fighter.position.set(0,10,10)
        ground[0].position.set(-40,0,0)
        ground[1].position.set(-20,0,0)
        ground[2].position.set( 0,0,0)
        ground[3].position.set( 20,0,0)
        ground[4].position.set( 40,0,0)
        console.log(ground)

        house.position.set(0,0,0)
        helicopter.position.set(-20,20,0)
        // console.log(Santa.add(gift1))
        // ground.scale.set(5,1,5)
        // for (let i = 0; i < energy.length; i++) {
        //     energy[i].position.set((Math.random() * 20) - 10, 1, -30 - i * 30);
        //     energy[i].angularVelocity = new THREE.Vector3().random();
        // }
        // for (let i = 0; i < rock1.length; i++) {
        //     rock1[i].position.set((Math.random() * 20) - 10, 1, -15 - i * 30);
        //     rock1[i].angularVelocity = new THREE.Vector3().random();
        // }
        // for(let i=0;i<bullets.length;i++){
        //     bullets[i].position.z=-300
        // }   
        
        function startLoop(){
        intervalID=
        setInterval(function() {
            // console.log(keys)
            // 戰機移動+轉動
            Santa.rotation.z = 0
            if((keys['w']||keys['arrowup']) && Santa.position.y<=20) {
                Santa.position.y += .2;
                // Santa.rotation.z = Math.PI/8
            }
            else if((keys['w']||keys['arrowup'])) {
                // Santa.rotation.z = Math.PI/8
            }
            else if(Santa.position.y>1.2) {
                Santa.position.y -= .1;
                // fighter.rotation.z = -Math.PI/8
            }

            if((keys['e']||keys['arrowup']) && gift1.parent === Santa){
                Santa.remove(gift1)
                scene.add(gift1)
                gift1.position.copy(Santa.position);
            }
            if (gift1.parent === scene) {
                gift1.position.x+=.3
                gift1.position.y+= gift1.Vy
                gift1.Vy+=Ay
                gift1.rotation.z+=.1
            }
            if (gift1.position.y<-1){
                gift1.position.set(0,0,0)
                scene.remove(gift1)
                Santa.add(gift1)
                gift1.Vy=.1
                gift1.rotation.z=0
            }

            house.position.x-=.2
            if(house.position.x<-50){house.position.x=50}
            building.position.x-=.2
            if(building.position.x<-50){building.position.x=50}
            helicopter.position.x-=.2
            if(helicopter.position.x<-50){helicopter.position.x=50}

        },10)
        }startLoop()
    }
    
// gameProcess()
    window.addEventListener("load", function() {
        const startButton = document.getElementById("startButton");
        startButton.addEventListener("click", function() {
            clearInterval(intervalID);
            gameProcess(); // 點擊按鈕後觸發遊戲流程函數
        });
    });
</script>