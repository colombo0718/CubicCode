<head>
    <style>
        body {
            margin: 0px;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1fr; /* 定义列比例 */
            height: 100vh; /* 使用视窗高度作为容器高度 */
        }

        .blockly-panel {
            height: 100%; /* 充满容器的高度 */
        }

        .canvas-panel {
            display: grid;
            grid-template-rows: 5fr 1fr; /* 定义行比例 */
            height: 100%; /* 充满容器的高度 */
        }

        .canvas-container {
            width: 100%;
            height: 100%;
        }


        #canvas {
            width: 100%; /* 使用相对宽度 */
            height: 100%; /* 使用相对高度 */
            text-align: center;
        }

        /* 隐藏垃圾桶图标 */
        .blocklyTrashIcon {
            display: none !important;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="canvas-panel" > 
        <div class="canvas-container">
            <div id="canvas"></div>
        </div>
        <div class="ui-container">
            <div class="level-selector">
                <label>選擇關卡:</label>
                <label><input type="radio" name="level" value="01">01</label>
                <label><input type="radio" name="level" value="02">02</label>
                <label><input type="radio" name="level" value="03">03</label>
                <label><input type="radio" name="level" value="04">04</label>
                <label><input type="radio" name="level" value="05">05</label>
                <label><input type="radio" name="level" value="06">06</label>
                <label><input type="radio" name="level" value="07">07</label>
                <label><input type="radio" name="level" value="08">08</label>
                <label><input type="radio" name="level" value="09">09</label>
                <label><input type="radio" name="level" value="10">10</label>
            </div>

            <input type="file" id="fileInput" accept=".vox" />
            <button id="showActions">Show Actions</button>
            <button id="runButton">Run Car</button>
        </div>    
    </div>
    <div  class="blockly-panel" > 
        <div id="blocklyDiv"></div>
    </div>
</div>
<script src="https://unpkg.com/blockly/blockly.min.js"></script>
<script type="importmap">
    {
        "imports": {
            "three": "https://threejs.org/build/three.module.js",
            "three/addons/": "https://threejs.org/examples/jsm/"
        }
    }
</script>
<script type="module">


        // 定义积木
        Blockly.Blocks['move_forward'] = {
          init: function() {
            this.appendDummyInput()
                .appendField("前进");
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour(160);
            this.setTooltip("");
            this.setHelpUrl("");
          }
        };

        Blockly.Blocks['turn_left'] = {
          init: function() {
            this.appendDummyInput()
                .appendField("左转");
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour(160);
            this.setTooltip("");
            this.setHelpUrl("");
          }
        };

        Blockly.Blocks['turn_right'] = {
          init: function() {
            this.appendDummyInput()
                .appendField("右转");
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour(160);
            this.setTooltip("");
            this.setHelpUrl("");
          }
        };

        // 生成 JavaScript 代码
        Blockly.JavaScript['move_forward'] = function(block) {
          var code = 'moveForward();\n';
          return code;
        };

        Blockly.JavaScript['turn_left'] = function(block) {
          var code = 'turnLeft();\n';
          return code;
        };

        Blockly.JavaScript['turn_right'] = function(block) {
          var code = 'turnRight();\n';
          return code;
        };

        // Blockly 配置
        var workspace = Blockly.inject('blocklyDiv', {
            toolbox: `
                <xml>
                    <block type="move_forward"></block>
                    <block type="turn_left"></block>
                    <block type="turn_right"></block>
                    <block type="controls_repeat_ext">
                        <value name="TIMES">
                            <shadow type="math_number">
                                <field name="NUM">4</field>
                            </shadow>
                        </value>
                    </block>
                </xml>
            `
        });

        
        // 生成并运行代码
        function runCode() {
            actions=''
            var code = Blockly.JavaScript.workspaceToCode(workspace);
            eval(code);
            console.log(code)
            console.log(actions)
        }


        var showbutton=document.getElementById('showActions');
        showbutton.addEventListener('click',runCode)


    import * as THREE from 'three';
    // import { VOXLoader, VOXMesh } from 'three/addons/loaders/VOXLoader.js';
    import { VOXLoader, VOXMesh } from 'https://cubiccode.vercel.app/VOXLoader_mine.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    var fileInput = document.getElementById('fileInput');
    var canvas = document.getElementById('canvas');
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
    var renderer = new THREE.WebGLRenderer({ antialias: true });

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

    renderer.setSize(canvas.clientWidth, canvas.clientHeight)
    canvas.appendChild(renderer.domElement);

    // 設置相機
    camera.position.set(0,6,6)

    // 添加燈光
    var ambientLight = new THREE.AmbientLight(0xffffff, 1); // 產生柔和的光
    scene.add(ambientLight);

    var directionalLight = new THREE.DirectionalLight(0xffffff, 2); // 產生方向光
    directionalLight.position.set(-10, 20, 10);
    directionalLight.castShadow = true; // 讓此光能產生陰影

    // 設定光源可產生影子的範圍與精細度
    directionalLight.shadow.camera.left = -20;
    directionalLight.shadow.camera.right = 20;
    directionalLight.shadow.camera.top = 20;
    directionalLight.shadow.camera.bottom = -20;
    directionalLight.shadow.camera.near = .1;
    directionalLight.shadow.camera.far = 200;

    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;

    scene.add(directionalLight)

    // 添加網格
    var gridSize = 10; // 網格大小
    var gridDivisions = 10; // 網格分段數
    var gridSpace = new THREE.GridHelper(gridSize, gridDivisions, 0xffffff, 0xaaaaaa);
    gridSpace.position.y = 0; // 放置在y=0的面上
    scene.add(gridSpace);


    // 加入地板
    const planeGeometry = new THREE.PlaneGeometry(10, 10);
    const planeMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
    const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
    planeMesh.rotation.x = -Math.PI / 2;
    planeMesh.receiveShadow = true
    planeMesh.castShadow = true;
    scene.add(planeMesh);

    // 创建道路陣列
    var roadArray=[]
    for(var j=0;j<9;j++){
        roadArray.push([])
    for(var i=0;i<17;i++){
        var roadMesh
        if(i%2==0){
            var roadGeometry = new THREE.BoxGeometry(0.2, 0.01, 1.2);
            var roadMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
            roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
            roadMesh.position.set(i/2-4,0,j-4-0.5); // 稍微抬高以避免与地板重叠
            scene.add(roadMesh);
        }else{
            var roadGeometry = new THREE.BoxGeometry(1.2, 0.01, 0.2);
            var roadMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
            roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
            roadMesh.position.set(i/2-4,0,j-4); // 稍微抬高以避免与地板重叠
            scene.add(roadMesh);
        }
        roadArray[j].push(roadMesh)
    }
    }
    console.log(roadArray)

    // 根據地圖重構街道
    var mapStr=[' _ _ _ _ _ _ _ _ ',
                '|_|_|_|_|_|_|_|_|',
                '|_|_|_|_|_|_|_|_|',
                '|_|_|_|_|_|_|_|_|',
                '|_|_|_ _|_|_|_|_|',
                '|_|_|_|_| |_|_|_|',
                '|_|_|_|_|_|_|_|_|',
                '|_|_|_|_|_|_|_|_|',
                '|_|_|_|_|_|_|_|_|']

    // 根據地圖重構街道
    var mapStr=['                 ',
                '        |        ',
                '        |        ',
                '        |        ',
                '        |        ',
                '                 ',
                '                 ',
                '                 ',
                '                 ']

    function buildStreet(mapStr){
        for(var j=0;j<9;j++){
        for(var i=0;i<17;i++){
            if(mapStr[j][i]==' '){
                roadArray[j][i].visible=false
            }
        }}
    }
    buildStreet(mapStr)



    // 建置vox動畫必要物件
    const loader = new VOXLoader();
    var police= new THREE.Object3D();
    scene.add( police );  
    const meshes = [];
    let currentIndex = 0;

    // 建置vox動畫流程
    function processVoxelAnimation(chunks) {
        // 清除voxel動畫物件
        while (police.children.length > 0) { 
            police.remove(police.children[0]); 
        }
        meshes.length = 0;

        for (let i = 0; i < chunks.length; i++) {
            const chunk = chunks[i];
            const mesh = new VOXMesh(chunk);
            // mesh.material.metalness=true
            // mesh.material.roughness=1
            mesh.scale.setScalar(.01);
            mesh.visible = false;

            mesh.receiveShadow = true
            mesh.castShadow = true;

            meshes.push(mesh);
            police.add(mesh);
        }
    }


     // 載入預設檔案
     loader.load( 'https://cubiccode.vercel.app/policeThief/PoliceCar.vox', function ( chunks ) {
        processVoxelAnimation(chunks);
        // 開始動畫
        setInterval(function() {
            // 將前一個物件隱藏
            meshes[currentIndex % meshes.length].visible = false;
            currentIndex +=1
            // 將新的物件顯示
            meshes[currentIndex % meshes.length].visible = true;
            // anima.position.z-=.5            
        },100)
    } );

    // 用戶點選檔案後
    fileInput.addEventListener('change', function (event) { 
        var file = event.target.files[0];
        var reader = new FileReader();

        reader.onload = function (event) {
            var contents = event.target.result;
            var chunks= loader.parse(contents)
            console.log(chunks)

            processVoxelAnimation(chunks);
        };
        reader.readAsArrayBuffer(file);
    });


    // var actions='FRFLFRFLFRFLF'
    var actions='FRFLFRFLFRFLFRFL'
    var runtime=0.00
    let intervalId;
    var runbutton=document.getElementById('runButton');
    runbutton.addEventListener('click',function(){
        // runCode()
        clearInterval(intervalId);
        police.position.set(0,0,0)
        police.rotation.set(0,0,0)
        runtime=0.00
        intervalId = setInterval(function() {
            // console.log(police.position.x)
            
            runtime+=0.01
            var nowAction=actions[Math.floor(runtime)]
            // console.log(nowAction)
            if(nowAction=='F'){
                // 角度拉回0~2pi
                if(police.rotation.y>=2*Math.PI){
                    police.rotation.y-=2*Math.PI
                }else if(police.rotation.y<0 ){
                    police.rotation.y+=2*Math.PI
                }
                // 校正角度並前進  
                console.log(police.rotation.y)
                if(Math.abs(police.rotation.y-0)<0.1
                || Math.abs(police.rotation.y-4*Math.PI/2)<0.1){
                    police.rotation.y=0
                    police.position.z-=.01
                }
                if(Math.abs(police.rotation.y-Math.PI/2)<0.1){
                    police.rotation.y=Math.PI/2
                    police.position.x-=.01
                }
                if(Math.abs(police.rotation.y-Math.PI)<0.1){
                    police.rotation.y=Math.PI
                    police.position.z+=.01
                }
                if(Math.abs(police.rotation.y-3*Math.PI/2)<0.1){
                    police.rotation.y=3*Math.PI/2
                    police.position.x+=.01
                }
            }
            // 左右轉
            if(nowAction=='R'){police.rotation.y-=Math.PI/200}
            if(nowAction=='L'){police.rotation.y+=Math.PI/200}
        },10)
    })


    function moveForward() {
        actions += 'F';
    }

    function turnLeft() {
        actions += 'L';
    }

    function turnRight() {
        actions += 'R';
    }


   

    // 添加OrbitControls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan=false

    // 保存初始相机与目标的相对位置
    let initialCameraOffset = new THREE.Vector3().subVectors(camera.position, controls.target);

    controls.addEventListener('change', () => {
        // 更新初始相机与目标的相对位置
        initialCameraOffset = new THREE.Vector3().subVectors(camera.position, controls.target);
    });

    // 繪製畫面
    setInterval(function() {
        renderer.render(scene, camera);

        // 更新相机位置，使其保持与目标的相对位置不变
        camera.position.copy(police.position).add(initialCameraOffset);
        // 锁定目标到立方体
        controls.target.copy(police.position);
        controls.update(); // 需要加入這行才能讓OrbitControls工作
    },10)
</script>
</body>

