<style>
    body {
        margin: 0px;
        /* overflow: hidden; */
    }
</style>
<div id="canvas" ></div>
<input type="file" id="fileInput" accept=".vox" />
<button id="runButton">Run Car</button>
<script type="importmap">
    {
        "imports": {
            "three": "https://threejs.org/build/three.module.js",
            "three/addons/": "https://threejs.org/examples/jsm/"
        }
    }
</script>
<script type="module">
    import * as THREE from 'three';
    // import { VOXLoader, VOXMesh } from 'three/addons/loaders/VOXLoader.js';
    import { VOXLoader, VOXMesh } from 'https://cubiccode.vercel.app/VOXLoader_mine.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    var fileInput = document.getElementById('fileInput');
    var canvas = document.getElementById('canvas');
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth /(window.innerHeight-30), 0.1, 1000);
    var renderer = new THREE.WebGLRenderer({ antialias: true });

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

    renderer.setSize(window.innerWidth,(window.innerHeight-30));
    canvas.appendChild(renderer.domElement);

    // 設置相機
    camera.position.set(0,6,6)

    // 添加燈光
    var ambientLight = new THREE.AmbientLight(0xffffff, 1); // 產生柔和的光
    scene.add(ambientLight);

    var directionalLight = new THREE.DirectionalLight(0xffffff, 2); // 產生方向光
    directionalLight.position.set(-10, 20, 10);
    directionalLight.castShadow = true; // 讓此光能產生陰影

    // 設定光源可產生影子的範圍與精細度
    directionalLight.shadow.camera.left = -20;
    directionalLight.shadow.camera.right = 20;
    directionalLight.shadow.camera.top = 20;
    directionalLight.shadow.camera.bottom = -20;
    directionalLight.shadow.camera.near = .1;
    directionalLight.shadow.camera.far = 200;

    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;

    scene.add(directionalLight);

    // const pointLight1 = new THREE.PointLight(0xffffff,10);
    // pointLight1.position.set(2, 2, 2);
    // pointLight1.castShadow = true; // 讓此光能產生陰影
    // scene.add(pointLight1);

    // const pointLight2 = new THREE.PointLight(0xffffff,10);
    // pointLight2.position.set(-2, 2, -2);
    // pointLight2.castShadow = true; // 讓此光能產生陰影
    // scene.add(pointLight2);

    // 添加網格
    var gridSize = 10; // 網格大小
    var gridDivisions = 10; // 網格分段數
    var gridSpace = new THREE.GridHelper(gridSize, gridDivisions, 0xffffff, 0xaaaaaa);
    gridSpace.position.y = 0; // 放置在y=0的面上
    scene.add(gridSpace);


        // // 創建方塊幾何體
        // const geometry = new THREE.BoxGeometry(40, .05, 40); // 方塊的尺寸

        // // 創建綠色材質
        // const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 }); // 綠色

        // // 創建網格（方塊）
        // const cube = new THREE.Mesh(geometry, material);

        // cube.receiveShadow = true
        // cube.castShadow = true;
        // // cube.clipShadows = true;


    // 加入地板
    const planeGeometry = new THREE.PlaneGeometry(10, 10);
    const planeMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
    const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
    planeMesh.rotation.x = -Math.PI / 2;
    planeMesh.receiveShadow = true
    planeMesh.castShadow = true;
    scene.add(planeMesh);

    // 创建道路
    var roadArray=[]
    for(var j=0;j<9;j++){
        roadArray.push([])
    for(var i=0;i<17;i++){
        var roadMesh
        if(i%2==0){
            var roadGeometry = new THREE.BoxGeometry(0.2, 0.01, 1.2);
            var roadMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
            roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
            roadMesh.position.set(i/2-4,0,j-4-0.5); // 稍微抬高以避免与地板重叠
            scene.add(roadMesh);
        }else{
            var roadGeometry = new THREE.BoxGeometry(1.2, 0.01, 0.2);
            var roadMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
            roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
            roadMesh.position.set(i/2-4,0,j-4); // 稍微抬高以避免与地板重叠
            scene.add(roadMesh);
        }
        roadArray[j].push(roadMesh)
    }
    }
    console.log(roadArray)


    // 添加OrbitControls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan=false

    // 建置vox動畫必要物件
    const loader = new VOXLoader();
    var police= new THREE.Object3D();
    scene.add( police );  
    const meshes = [];
    let currentIndex = 0;

    // 建置vox動畫流程
    function processVoxelAnimation(chunks) {
        // 清除voxel動畫物件
        while (police.children.length > 0) { 
            police.remove(police.children[0]); 
        }
        meshes.length = 0;

        for (let i = 0; i < chunks.length; i++) {
            const chunk = chunks[i];
            const mesh = new VOXMesh(chunk);
            // mesh.material.metalness=true
            // mesh.material.roughness=1
            mesh.scale.setScalar(.01);
            mesh.visible = false;

            mesh.receiveShadow = true
            mesh.castShadow = true;

            meshes.push(mesh);
            police.add(mesh);
        }
    }

    // var actions='FRFLFRFLFRFLF'
    var actions='FRFRFRFRFRFRFRFRFRFRFRFRFRFRFR'
    var runtime=0.00
    var runbutton=document.getElementById('runButton');
    runbutton.addEventListener('click',function(){
        runtime=0.00
        setInterval(function() {
            console.log(police.position.x)
            runtime+=0.01
            var nowAction=actions[Math.floor(runtime)]
            if(nowAction=='F'){
                // 角度拉回0~2pi
                if(police.rotation.y>2*Math.PI){
                    police.rotation.y-=2*Math.PI
                }else if(police.rotation.y<0 ){
                    police.rotation.y+=2*Math.PI
                }
                // 校正角度並前進  
                if(Math.abs(police.rotation.y-0)<0.1){
                    police.rotation.y=0
                    police.position.z-=.01
                }
                if(Math.abs(police.rotation.y-Math.PI/2)<0.1){
                    police.rotation.y=Math.PI/2
                    police.position.x-=.01
                }
                if(Math.abs(police.rotation.y-Math.PI)<0.1){
                    police.rotation.y=Math.PI
                    police.position.z+=.01
                }
                if(Math.abs(police.rotation.y-3*Math.PI/2)<0.1){
                    police.rotation.y=3*Math.PI/2
                    police.position.x+=.01
                }
            }
            // 左右轉
            if(nowAction=='R'){police.rotation.y-=Math.PI/200}
            if(nowAction=='L'){police.rotation.y+=Math.PI/200}
        },10)
    })

    // 載入預設檔案
    loader.load( 'https://cubiccode.vercel.app/policeThief/PoliceCar.vox', function ( chunks ) {
        processVoxelAnimation(chunks);
        // 開始動畫
        setInterval(function() {
            // 將前一個物件隱藏
            meshes[currentIndex % meshes.length].visible = false;
            currentIndex +=1
            // 將新的物件顯示
            meshes[currentIndex % meshes.length].visible = true;
            // anima.position.z-=.5            
        },100)
    } );


    // 保存初始相机与目标的相对位置
    let initialCameraOffset = new THREE.Vector3().subVectors(camera.position, controls.target);

    controls.addEventListener('change', () => {
        // 更新初始相机与目标的相对位置
        initialCameraOffset = new THREE.Vector3().subVectors(camera.position, controls.target);
    });

    // 繪製畫面
    setInterval(function() {
        renderer.render(scene, camera);

        // 更新相机位置，使其保持与目标的相对位置不变
        camera.position.copy(police.position).add(initialCameraOffset);
        // 锁定目标到立方体
        controls.target.copy(police.position);
        controls.update(); // 需要加入這行才能讓OrbitControls工作
    },10)

    // 用戶點選檔案後
    fileInput.addEventListener('change', function (event) { 
        var file = event.target.files[0];
        var reader = new FileReader();

        reader.onload = function (event) {
            var contents = event.target.result;
            var chunks= loader.parse(contents)
            console.log(chunks)

            processVoxelAnimation(chunks);
        };
        reader.readAsArrayBuffer(file);
    });

    var mapStr=[' _ _ _ _ _ _ _ _ ',
                '|_|_|_|_|_|_|_|_|',
                '|_|_|_|_|_|_|_|_|',
                '|_|_|_|_|_|_|_|_|',
                '|_|_|_|_|_|_|_|_|',
                '|_|_|_|_|_|_|_|_|',
                '|_|_|_|_|_|_|_|_|',
                '|_|_|_|_|_|_|_|_|',
                '|_|_|_|_|_|_|_|_|']
    for(var j=0;j<9;j++){
    for(var i=0;i<17;i++){
        if(mapStr[j][i]==' '){
            roadArray[j][i].visible=false
        }
    }}
</script>

